<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>3D Audio Agent — Interactive Visualizer</title>

    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Montserrat"
    />
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    />

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: "Montserrat", sans-serif;
        background: #0b0b0f;
        color: #e6eef8;
        overflow: hidden;
      }
      #app {
        position: relative;
        width: 100%;
        height: 100vh;
      }

      canvas#background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        display: block;
      }

      /* center controls */
      .ui-panel {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 22px;
        z-index: 20;
        background: rgba(0, 0, 0, 0.45);
        padding: 12px 14px;
        border-radius: 12px;
        backdrop-filter: blur(6px);
        box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6);
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .btn-ghost {
        background: rgba(255, 255, 255, 0.06);
        color: #e6eef8;
        border: none;
      }

      /* sidebar */
      .settings-sidebar {
        position: absolute;
        right: 18px;
        top: 18px;
        z-index: 30;
        width: 320px;
        max-width: 86vw;
        background: linear-gradient(
          180deg,
          rgba(12, 12, 20, 0.9),
          rgba(8, 8, 12, 0.8)
        );
        border-radius: 12px;
        padding: 14px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.65);
        transform: translateX(0);
        transition: transform 0.34s ease;
      }

      .settings-sidebar.hidden {
        transform: translateX(360px);
      }

      .settings-sidebar h5 {
        margin: 0 0 8px 0;
        color: #fff;
      }

      .settings-row {
        margin-bottom: 10px;
      }

      .vu-meter {
        width: 120px;
        height: 12px;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        overflow: hidden;
        display: inline-block;
        vertical-align: middle;
        margin-left: 8px;
      }
      .vu-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #3be1c6, #18c02c, #ee3bcf);
        transition: width 0.05s linear;
      }

      .transcript {
        height: 84px;
        overflow: auto;
        background: rgba(255, 255, 255, 0.02);
        padding: 8px;
        border-radius: 8px;
        font-size: 13px;
        color: #cfefff;
      }

      .top-left-badge {
        position: absolute;
        left: 18px;
        top: 18px;
        z-index: 30;
        background: rgba(0, 0, 0, 0.45);
        padding: 8px 12px;
        border-radius: 10px;
        font-weight: 600;
        color: #e6eef8;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.55);
      }

      label.small {
        font-size: 12px;
        opacity: 0.85;
      }

      input[type="range"] {
        width: 100%;
      }

      .small-muted {
        font-size: 12px;
        color: #9fb0c9;
        opacity: 0.9;
      }

      /* responsive tweak */
      @media (max-width: 520px) {
        .settings-sidebar {
          width: 92vw;
          right: 6px;
          top: 12px;
        }
        .ui-panel {
          left: 50%;
          transform: translateX(-50%);
          padding: 8px;
          bottom: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas id="background"></canvas>

      <div class="top-left-badge">3D Audio Agent</div>

      <!-- Settings sidebar -->
      <div id="sidebar" class="settings-sidebar hidden" aria-hidden="true">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
          "
        >
          <h5>Settings</h5>
          <button id="closeSidebar" class="btn btn-sm btn-ghost">Hide</button>
        </div>

        <div class="settings-row">
          <label class="small"
            >Noise Coef <span id="lbl-noise" class="small-muted">—</span></label
          >
          <input id="noiseRange" type="range" min="1" max="100" />
        </div>

        <div class="settings-row">
          <label class="small"
            >Height Coef
            <span id="lbl-height" class="small-muted">—</span></label
          >
          <input id="heightRange" type="range" min="1" max="100" />
        </div>

        <div class="settings-row">
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
            "
          >
            <div>
              <label class="small">Audio-reactive</label>
              <div class="small-muted">Use mic volume to drive height</div>
            </div>
            <input id="reactiveToggle" type="checkbox" />
          </div>
        </div>

        <div class="settings-row">
          <label class="small">VU Meter</label>
          <div class="vu-meter"><div id="vuFill" class="vu-fill"></div></div>
        </div>

        <hr
          style="
            border: 0;
            border-top: 1px dashed rgba(255, 255, 255, 0.04);
            margin: 8px 0;
          "
        />

        <div
          style="
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 6px;
          "
        >
          <button id="startMic" class="btn btn-sm btn-ghost">Start Mic</button>
          <button id="stopMic" class="btn btn-sm btn-ghost" disabled>
            Stop Mic
          </button>
          <button id="randColor" class="btn btn-sm btn-ghost">
            Random Colors
          </button>
        </div>

        <div style="margin-top: 8px">
          <label class="small">Transcript</label>
          <div id="transcript" class="transcript">
            Listening transcript will appear here...
          </div>
          <div style="display: flex; gap: 8px; margin-top: 8px">
            <button id="listenBtn" class="btn btn-sm btn-ghost">
              Start Listening
            </button>
            <button id="stopListenBtn" class="btn btn-sm btn-ghost" disabled>
              Stop Listening
            </button>
            <button id="autoReply" class="btn btn-sm btn-ghost">
              Auto-reply: Off
            </button>
          </div>
        </div>

        <hr
          style="
            border: 0;
            border-top: 1px dashed rgba(255, 255, 255, 0.04);
            margin: 8px 0;
          "
        />

        <div>
          <label class="small">Agent Speak</label>
          <textarea
            id="speakText"
            rows="2"
            class="form-control"
            placeholder="Type text for the agent to speak..."
          ></textarea>
          <div style="display: flex; gap: 8px; margin-top: 8px">
            <button id="speakBtn" class="btn btn-sm btn-ghost">Speak</button>
            <button id="stopSpeakBtn" class="btn btn-sm btn-ghost" disabled>
              Stop
            </button>
          </div>
        </div>
      </div>

      <!-- small center control bar -->
      <div class="ui-panel">
        <button id="toggleSidebar" class="btn btn-sm btn-ghost">
          Settings
        </button>
        <button id="toggleListen" class="btn btn-sm btn-ghost">
          Start Listening
        </button>
        <button id="toggleSpeak" class="btn btn-sm btn-ghost">
          Speak Text
        </button>
        <button id="randomColorsCenter" class="btn btn-sm btn-ghost">
          Random Colors
        </button>
        <div style="font-size: 12px; color: #bfe6ff; margin-left: 8px">
          Mic: <span id="micStatus">off</span>
        </div>
      </div>
    </div>

    <!-- libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/100/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>

    <script>
      // ---- Config / state ----
      const conf = {
        fov: 75,
        cameraZ: 75,
        xyCoef: 50, // default noise mapping
        zCoef: 10, // default height coef
        lightIntensity: 0.9,
        ambientColor: 0x000000,
        light1Color: 0x0e09dc,
        light2Color: 0x1cd1e1,
        light3Color: 0x18c02c,
        light4Color: 0xee3bcf,
        audioReactive: false,
      };

      // elements
      const canvas = document.getElementById("background");
      const noiseRange = document.getElementById("noiseRange");
      const heightRange = document.getElementById("heightRange");
      const lblNoise = document.getElementById("lbl-noise");
      const lblHeight = document.getElementById("lbl-height");
      const sidebar = document.getElementById("sidebar");
      const toggleSidebar = document.getElementById("toggleSidebar");
      const closeSidebar = document.getElementById("closeSidebar");
      const reactiveToggle = document.getElementById("reactiveToggle");
      const vuFill = document.getElementById("vuFill");
      const startMicBtn = document.getElementById("startMic");
      const stopMicBtn = document.getElementById("stopMic");
      const micStatus = document.getElementById("micStatus");
      const listenBtn = document.getElementById("listenBtn");
      const stopListenBtn = document.getElementById("stopListenBtn");
      const transcriptEl = document.getElementById("transcript");
      const autoReplyBtn = document.getElementById("autoReply");
      const speakText = document.getElementById("speakText");
      const speakBtn = document.getElementById("speakBtn");
      const stopSpeakBtn = document.getElementById("stopSpeakBtn");
      const randColor = document.getElementById("randColor");
      const randomColorsCenter = document.getElementById("randomColorsCenter");
      const toggleListen = document.getElementById("toggleListen");
      const toggleSpeak = document.getElementById("toggleSpeak");

      // init range defaults
      noiseRange.value = 101 - conf.xyCoef;
      heightRange.value = (conf.zCoef * 100) / 25;
      lblNoise.textContent = noiseRange.value;
      lblHeight.textContent = heightRange.value;

      // ---------- Three.js scene ----------
      let renderer, scene, camera, plane, light1, light2, light3, light4;
      let width, height, wWidth, wHeight;
      const simplex = new SimplexNoise();
      const mouse = new THREE.Vector2();
      const raycaster = new THREE.Raycaster();
      let mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      const mousePosition = new THREE.Vector3();

      initThree();
      animate();

      function initThree() {
        renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: true,
        });
        camera = new THREE.PerspectiveCamera(
          conf.fov,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = conf.cameraZ;

        updateSize();
        window.addEventListener("resize", updateSize);

        document.addEventListener("mousemove", (e) => {
          const v = new THREE.Vector3();
          camera.getWorldDirection(v);
          v.normalize();
          mousePlane.normal = v;
          mouse.x = (e.clientX / width) * 2 - 1;
          mouse.y = -(e.clientY / height) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          raycaster.ray.intersectPlane(mousePlane, mousePosition);
        });

        scene = new THREE.Scene();
        initLights();
        initPlane();
      }

      function initPlane() {
        const mat = new THREE.MeshLambertMaterial({
          color: 0xffffff,
          side: THREE.DoubleSide,
        });
        const segX = Math.round(wWidth / 2);
        const segY = Math.round(wHeight / 2);
        const geo = new THREE.PlaneBufferGeometry(
          wWidth,
          wHeight,
          Math.max(segX, 10),
          Math.max(segY, 10)
        );
        plane = new THREE.Mesh(geo, mat);
        plane.rotation.x = -Math.PI / 2 - 0.2;
        plane.position.y = -25;
        scene.add(plane);
        camera.position.z = 60;
      }

      function initLights() {
        const r = 30,
          y = 10,
          lightDistance = 500;
        light1 = new THREE.PointLight(
          conf.light1Color,
          conf.lightIntensity,
          lightDistance
        );
        light1.position.set(0, y, r);
        scene.add(light1);
        light2 = new THREE.PointLight(
          conf.light2Color,
          conf.lightIntensity,
          lightDistance
        );
        light2.position.set(0, -y, -r);
        scene.add(light2);
        light3 = new THREE.PointLight(
          conf.light3Color,
          conf.lightIntensity,
          lightDistance
        );
        light3.position.set(r, y, 0);
        scene.add(light3);
        light4 = new THREE.PointLight(
          conf.light4Color,
          conf.lightIntensity,
          lightDistance
        );
        light4.position.set(-r, y, 0);
        scene.add(light4);
      }

      function animate() {
        requestAnimationFrame(animate);
        animatePlane();
        animateLights();
        renderer.render(scene, camera);
      }

      function animatePlane() {
        if (!plane || !plane.geometry) return;
        const pos = plane.geometry.attributes.position.array;
        const time = Date.now() * 0.0002;
        // update z values (every vertex step 3)
        for (let i = 0; i < pos.length; i += 3) {
          pos[i + 2] =
            simplex.noise4D(
              pos[i] / conf.xyCoef,
              pos[i + 1] / conf.xyCoef,
              time,
              mouse.x + mouse.y
            ) * conf.zCoef;
        }
        plane.geometry.attributes.position.needsUpdate = true;
      }

      function animateLights() {
        const time = Date.now() * 0.001;
        const d = 50;
        light1.position.x = Math.sin(time * 0.1) * d;
        light1.position.z = Math.cos(time * 0.2) * d;
        light2.position.x = Math.cos(time * 0.3) * d;
        light2.position.z = Math.sin(time * 0.4) * d;
        light3.position.x = Math.sin(time * 0.5) * d;
        light3.position.z = Math.sin(time * 0.6) * d;
        light4.position.x = Math.sin(time * 0.7) * d;
        light4.position.z = Math.cos(time * 0.8) * d;
      }

      function updateSize() {
        width = window.innerWidth;
        height = window.innerHeight;
        if (renderer && camera) {
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          const size = getRendererSize();
          wWidth = size[0];
          wHeight = size[1];
          // recreate plane geometry to better match new dimensions
          if (plane) {
            scene.remove(plane);
            initPlane();
          }
        }
      }

      function getRendererSize() {
        const cam = new THREE.PerspectiveCamera(camera.fov, camera.aspect);
        const vFOV = (cam.fov * Math.PI) / 180;
        const h = 2 * Math.tan(vFOV / 2) * Math.abs(conf.cameraZ);
        const w = h * cam.aspect;
        return [w, h];
      }

      // ---- UI wiring ----
      noiseRange.addEventListener("input", () => {
        lblNoise.textContent = noiseRange.value;
        conf.xyCoef = 101 - parseFloat(noiseRange.value);
      });
      heightRange.addEventListener("input", () => {
        lblHeight.textContent = heightRange.value;
        conf.zCoef = (parseFloat(heightRange.value) * 25) / 100;
      });

      toggleSidebar.addEventListener("click", () => {
        sidebar.classList.toggle("hidden");
        sidebar.setAttribute(
          "aria-hidden",
          sidebar.classList.contains("hidden")
        );
      });
      closeSidebar.addEventListener("click", () => {
        sidebar.classList.add("hidden");
        sidebar.setAttribute("aria-hidden", "true");
      });

      reactiveToggle.addEventListener("change", (e) => {
        conf.audioReactive = reactiveToggle.checked;
        if (conf.audioReactive) {
          // sync display labels immediately
          lblHeight.textContent = heightRange.value;
        }
      });

      randColor.addEventListener("click", updateLightsColors);
      randomColorsCenter.addEventListener("click", updateLightsColors);

      function updateLightsColors() {
        conf.light1Color = chroma.random().hex();
        conf.light2Color = chroma.random().hex();
        conf.light3Color = chroma.random().hex();
        conf.light4Color = chroma.random().hex();
        light1.color = new THREE.Color(conf.light1Color);
        light2.color = new THREE.Color(conf.light2Color);
        light3.color = new THREE.Color(conf.light3Color);
        light4.color = new THREE.Color(conf.light4Color);
      }

      // ---- Audio (microphone) ----
      let audioCtx = null;
      let analyser = null;
      let micStream = null;
      let dataArray = null;
      let rafMeter = null;
      let gainNode = null;

      async function startMic() {
        if (micStream) return;
        try {
          micStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: false,
          });
        } catch (err) {
          alert("Microphone access denied or not available.");
          console.error(err);
          return;
        }
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(micStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        dataArray = new Uint8Array(analyser.fftSize);
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 1;
        source.connect(gainNode);
        gainNode.connect(analyser);

        startMeter();
        micStatus.textContent = "on";
        startMicBtn.disabled = true;
        stopMicBtn.disabled = false;
      }

      function stopMic() {
        if (!micStream) return;
        const tracks = micStream.getTracks();
        tracks.forEach((t) => t.stop());
        micStream = null;
        if (audioCtx && audioCtx.state !== "closed") audioCtx.close();
        audioCtx = null;
        analyser = null;
        dataArray = null;
        cancelAnimationFrame(rafMeter);
        vuFill.style.width = "0%";
        micStatus.textContent = "off";
        startMicBtn.disabled = false;
        stopMicBtn.disabled = true;
      }

      function startMeter() {
        if (!analyser) return;
        function meterLoop() {
          analyser.getByteTimeDomainData(dataArray);
          // compute RMS
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            const v = (dataArray[i] - 128) / 128;
            sum += v * v;
          }
          const rms = Math.sqrt(sum / dataArray.length); // 0..~1
          // update VU meter
          const percent = Math.min(1, rms * 5); // scale a bit for visibility
          vuFill.style.width = percent * 100 + "%";

          // if reactive mode enabled, map rms to conf.zCoef (height)
          if (conf.audioReactive) {
            // map rms (0..0.6 typical) to a heightCoefficient range
            // baseHeight pulled from manual slider but modulated by audio:
            const manual = (parseFloat(heightRange.value) * 25) / 100;
            // make audio add/subtract proportionally
            conf.zCoef = manual + percent * 40; // tune multiplier as needed
          }

          // loop
          rafMeter = requestAnimationFrame(meterLoop);
        }
        rafMeter = requestAnimationFrame(meterLoop);
      }

      startMicBtn.addEventListener("click", startMic);
      stopMicBtn.addEventListener("click", stopMic);

      // ---- Speech recognition (listening / agent) ----
      let recognition = null;
      let listening = false;
      let autoReply = false;

      // Check for SpeechRecognition
      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition || null;
      if (SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.lang = "en-US";
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;

        recognition.addEventListener("result", (evt) => {
          let interim = "";
          let final = "";
          for (let i = 0; i < evt.results.length; i++) {
            const res = evt.results[i];
            if (res.isFinal) final += res[0].transcript;
            else interim += res[0].transcript;
          }
          transcriptEl.innerText =
            "Interim: " + interim + "\n\nFinal: " + final;
          transcriptEl.scrollTop = transcriptEl.scrollHeight;
          if (final && autoReply) {
            // basic auto reply rules — can be expanded
            setTimeout(() => {
              const response = generateAgentReply(final);
              speak(response);
            }, 250);
          }
        });

        recognition.addEventListener("end", () => {
          listening = false;
          listenBtn.innerText = "Start Listening";
          stopListenBtn.disabled = true;
        });

        recognition.addEventListener("error", (e) => {
          console.warn("Recognition error", e);
        });
      } else {
        listenBtn.disabled = true;
        stopListenBtn.disabled = true;
        transcriptEl.innerText =
          "SpeechRecognition not supported in this browser. Use Chrome/Edge.";
      }

      listenBtn.addEventListener("click", () => {
        if (!recognition) return;
        try {
          recognition.start();
          listening = true;
          listenBtn.innerText = "Listening...";
          stopListenBtn.disabled = false;
        } catch (e) {
          console.warn(e);
        }
      });
      stopListenBtn.addEventListener("click", () => {
        if (!recognition) return;
        recognition.stop();
        listening = false;
        listenBtn.innerText = "Start Listening";
        stopListenBtn.disabled = true;
      });

      autoReplyBtn.addEventListener("click", () => {
        autoReply = !autoReply;
        autoReplyBtn.innerText = "Auto-reply: " + (autoReply ? "On" : "Off");
      });

      // Simple rule-based agent reply generator (replace with API call if you want)
      function generateAgentReply(userText) {
        const t = userText.toLowerCase();
        if (t.includes("hello") || t.includes("hi"))
          return "Hello! How can I help you today?";
        if (t.includes("name")) return "I am your 3D Audio Agent.";
        if (t.includes("visual") || t.includes("wave"))
          return "I can change the plane based on the microphone level.";
        if (t.includes("color")) {
          updateLightsColors();
          return "I changed the colors.";
        }
        return (
          "I heard you say: " +
          userText +
          ". I can respond, change colors, or speak any text you type."
        );
      }

      // ---- Text-to-Speech (speaking) ----
      let utter = null;
      let speaking = false;
      function speak(text) {
        if (!("speechSynthesis" in window)) {
          alert("Speech Synthesis not supported in this browser.");
          return;
        }
        window.speechSynthesis.cancel();
        utter = new SpeechSynthesisUtterance(text);
        utter.rate = 1;
        utter.pitch = 1;
        utter.onstart = () => {
          speaking = true;
          stopSpeakBtn.disabled = false;
        };
        utter.onend = () => {
          speaking = false;
          stopSpeakBtn.disabled = true;
        };
        window.speechSynthesis.speak(utter);
      }

      speakBtn.addEventListener("click", () => {
        const text =
          speakText.value.trim() || "Hello, I am your 3D audio agent.";
        speak(text);
      });
      stopSpeakBtn.addEventListener("click", () => {
        window.speechSynthesis.cancel();
        stopSpeakBtn.disabled = true;
      });

      // UI center toggles
      toggleListen.addEventListener("click", () => {
        if (listening) {
          if (recognition) recognition.stop();
        } else {
          if (recognition) recognition.start();
        }
      });
      toggleSpeak.addEventListener("click", () => {
        const t =
          speakText.value.trim() || "This is a demo of the speaking AI agent.";
        speak(t);
      });

      // ---- small UX: clicking center random colors as well ----
      document
        .getElementById("randomColorsCenter")
        .addEventListener("click", updateLightsColors);

      // ---- small safety / fallback: on page hide stop audio ----
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          // optionally pause speech
          if (window.speechSynthesis) window.speechSynthesis.cancel();
        }
      });

      // ---- finishing touches ----
      // Provide keyboard shortcut: S toggles settings
      document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "s") {
          sidebar.classList.toggle("hidden");
        }
      });

      // expose a global for quick dev debug (optional)
      window._agentState = { conf };
    </script>
  </body>
</html>
